

module wrt_controller #(parameter n=32) (
                        
//Master to Slave
     output reg [n-1:0] m_axi_lite_awaddr, //address--> ouput from master to slave
     output reg m_axi_lite_awvalid, //valid signal generate by master to slave
     output reg [n-1:0]m_axi_lite_wdata, //data --> master to slave--through IP
     output reg m_axi_lite_wvalid, // valid signal generated by master to slave for writing data from slave
     output reg [(n/8)-1:0]m_axi_lite_wstrb, //strobe from master to slave --> through IP
     output reg m_axi_lite_bready, //ready signal from master to slave -- for getting response signal

// Master to IP

     output reg Bus2IP_Mst_CmdAck, //acknowledge signal from master to IP after succesfully reading address
     output reg Bus2IP_Mst_Cmplt, //From Master to IP , When data is fetched
     output reg Bus2IP_Mst_dst_Rdy_n, //Active low , generated from master to IP,indicating data asserted on bus is valid
     output reg md_error, //Active high master detected error output discrete 
     output reg BUS2IP_Mst_Error, 
     input m_axi_lite_aclk, //IP to master
     input m_axi_lite_aresetn, //active low reset IP to master
 
//IP to Master
     input IP2Bus_MstWr_Req, //write request from IP to Master
     input [n-1:0] IP2Bus_Mst_Addr, //address for both read and write IP to master
     input [n-1:0] IP2Bus_MstWr_d, //write data from ip to bus
     input [(n/8)-1:0]IP2Bus_Mst_BE, // strobe signal from ip to bus

//Slave to Master
     input m_axi_lite_awready, //ip==> Ready signal generated to get data from  master
     input m_axi_lite_wready, //ip==> ready signal generated to get data from master
     input m_axi_lite_bvalid, // valid response signal from slave to master for transferring response signal to master 
     input [1:0]m_axi_lite_bresp   //from slave to master to known that was operation OK or not
     );

     reg [2:0] present_state,next_state;          // registers of present_state and next state of FSM
     reg x;    // 0 when witing of data and address done at sametime 
               //means x will be 0 when master receives m_axi_lite_wready and m_axi_lite_awready same posedge of clk
               //x will be one if write of addr and writing of data done consecutively 

     // s0 to s5 are states of FSM 
   // To know more about FSM see Project Document
     parameter s0=3'b000;
     parameter s1=3'b001;
     parameter s2=3'b010;
     parameter s3=3'b011;
     parameter s4=3'b100;
     parameter s5=3'b101;

     always @ (posedge m_axi_lite_aclk , negedge m_axi_lite_aresetn)  begin 
          
          //On negedge of reset
          if (!m_axi_lite_aresetn)
            present_state<=s0;
          //On posedge of clk operation
          else 
            present_state<=next_state;         // Sequential part that every FSM has
     end
               
          // combinational part of FSM 
          // To calculate next state logic
     always @* begin
          //taken function that gives next state logic 
          next_state = next_state_logic_f (present_state,
                              m_axi_lite_aresetn,
                              IP2Bus_MstWr_Req,
                              m_axi_lite_awready,
                              m_axi_lite_wready,
                              m_axi_lite_bvalid);
     end
               
//---------------------------------------------- OUTPUT LOGIC ---------------------------------------------- 
               //----------------------------- A combinational Part----------------------------              
     always @* begin
             if (!m_axi_lite_aresetn)
               md_error<=0;

          case (present_state)          
               s0 : begin
                    m_axi_lite_bready<=0;
                    m_axi_lite_awvalid<=0;
                    m_axi_lite_wvalid<=0;
                    m_axi_lite_wstrb<=4'hF;
                    m_axi_lite_awaddr<=0;
                    Bus2IP_Mst_CmdAck<=0;
                    Bus2IP_Mst_Cmplt<=0;
                    BUS2IP_Mst_Error<=0;
                    m_axi_lite_wdata<=0;
                    Bus2IP_Mst_dst_Rdy_n<=1;      //this has default logic 1
                    //x<=0;                         
               end

               s1 : begin
                    m_axi_lite_awvalid<=1;        // To handshake from master to write address
                    m_axi_lite_wvalid<=1;         // To handshake from master to write data
                    m_axi_lite_bready<=1;         // To handshake from master to receive write response 
               end

               s2 : begin
                     if (m_axi_lite_awready & m_axi_lite_wready & m_axi_lite_wvalid & m_axi_lite_awvalid) begin
                       // if slave is ready to for both handshake to write
                              // data and address simultaneously   
                         m_axi_lite_awaddr <= IP2Bus_Mst_Addr;     //pass address to axi which usr given to master 
                         m_axi_lite_wstrb <= IP2Bus_Mst_BE;        //pass byte enable to axi which usr given to master  
                         m_axi_lite_wdata <= IP2Bus_MstWr_d;          //pass data to axi which usr given to master 
                         Bus2IP_Mst_CmdAck<=1;            //Give acknowledgement to user that adderess dumped in slave
                         m_axi_lite_awvalid<=0;                  // make awvalid logic 0 as address passed
                         //@ (posedge m_axi_lite_aclk);            // wait for 1 clk cycle to make acknowledgement to 0
                         Bus2IP_Mst_CmdAck<=0;
                    end
               end     

               s3 : begin
                    // when slave is ready for address to write
                    if (m_axi_lite_awready && m_axi_lite_awvalid ) begin
                         m_axi_lite_awaddr <= IP2Bus_Mst_Addr;        // passing address to AXI BUS
                         Bus2IP_Mst_CmdAck<=1;           // Give acknowledgement to user that adderess dumped in slave
                         m_axi_lite_awvalid<=0;                 // make awvalid logic 0 as address passed
                         //@ (posedge m_axi_lite_aclk);           // wait for 1 clk cycle to make acknowledgement to 0
                         Bus2IP_Mst_CmdAck<=0;
                    end
               end

               s4 : begin
                    // when slave is ready for data to write
                    if (m_axi_lite_wready && m_axi_lite_wvalid ) begin
                         m_axi_lite_wstrb <= IP2Bus_Mst_BE; // Pass strobe value acording to user given Byte_Enable BE
                         m_axi_lite_wdata <= IP2Bus_MstWr_d;        // Pass Data to AXI which user given to master 
                    end
               end 

               s5 : begin
                         
                    if(m_axi_lite_bresp>0)begin                //if bresp>0 means error occurred during operation
                         BUS2IP_Mst_Error<=1;                  // This will indicate that error in this operation a
                         md_error<=1;             // This will indicate error that occurred in this or any 
                                                  // previous operations which performe after 0 reset
                                                  // This md_error will indicate error by 1 untill reset goes to 0
                    end
                    else  BUS2IP_Mst_Error<=0;

                    m_axi_lite_bready<=0;                             // after getting response make bready 0
                    Bus2IP_Mst_Cmplt<=1;                              // acknowledge the user that write operation has performed
                    Bus2IP_Mst_dst_Rdy_n<=0;                          // destination ready to indicate the data 
               end
          endcase

               
     end

//-----------------------------------------------------------------------------------------------------------------



//---------------------------------------- NEXT STATE LOGIC -------------------------------------------
     function [2:0] next_state_logic_f;
          input [2:0] present_state;
          input m_axi_lite_aresetn,IP2Bus_MstWr_Req,m_axi_lite_awready,m_axi_lite_wready,m_axi_lite_bvalid;
          begin
          if (!m_axi_lite_aresetn)
               next_state_logic_f=s0;

          else begin      
          case (present_state)
               s0: begin
                    x=0;
                    if (!m_axi_lite_aresetn)
                         next_state_logic_f = s0;
                    else if (IP2Bus_MstWr_Req)
                         next_state_logic_f = s1;
               end
                    
               s1: begin
                    // if slave is ready to for both handshake to write
                            // data and address simultaneously   
                    if (m_axi_lite_awready & m_axi_lite_wready) begin
                         next_state_logic_f = s2;
                    end

                    // if slave is ready for handshake to write address only
                    else if (m_axi_lite_awready) begin
                         next_state_logic_f = s3;
                    end
                    
                    // if slave is ready for handshake to write data only
                    else if (m_axi_lite_wready) begin
                         next_state_logic_f = s4;
                    end
               end              

               s2: begin
                    // if slave is ready to send the response of write operation
                    if (m_axi_lite_bvalid) begin
                         next_state_logic_f = s5;
                    end
               end

               s3: begin

                    // if slave is ready to send the response of write operation
                    // check x==1 to avoid master to go in final stage with by writing address and not data
                    if ((x==1) && (m_axi_lite_bvalid)) begin
                         next_state_logic_f = s5;
                    end 
                    // after writing address if slave is ready for handshake to write data
                    else if (m_axi_lite_wready) begin
                         x=1;           //By this master will able to receive response as 
                                        //it performed both writting of data and address
                         next_state_logic_f = s4;
                    end
               end

               s4: begin

                    // if slave is ready to send the response of write operation
                    // check x==1 to avoid master to go in final stage with by writing data and not address
                    if ((x==1) && (m_axi_lite_bvalid)) begin
                         next_state_logic_f = s5;
                    end 
                    // after writing address if slave is ready for handshake to write address
                    else if (m_axi_lite_awready) begin
                         x=1;           //By this master will able to receive response as 
                                        //it performed both writting of data and address
                         next_state_logic_f = s3;
                    end
               end

               s5 : begin
                    // Once response received by master move to state s0 and
                    // wait for new read and write requests
                    next_state_logic_f = s0;
               end

          endcase
          end
          end
     endfunction
//-------------------------------------------------------------------------------------------------------------
endmodule      
